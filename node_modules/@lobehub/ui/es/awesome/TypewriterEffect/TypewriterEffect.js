'use client';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["sentences", "as", "typingSpeed", "initialDelay", "pauseDuration", "deletingSpeed", "deletePauseDuration", "loop", "className", "color", "showCursor", "hideCursorWhileTyping", "cursorCharacter", "cursorClassName", "cursorColor", "cursorBlinkDuration", "cursorFade", "cursorStyle", "textColors", "variableSpeed", "onSentenceComplete", "startOnVisible", "reverseMode", "segmentMode"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
import { motion } from 'framer-motion';
import { createElement, memo, useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useStyles } from "./style";
import { jsx as _jsx } from "react/jsx-runtime";
import { Fragment as _Fragment } from "react/jsx-runtime";
import { jsxs as _jsxs } from "react/jsx-runtime";
var TypewriterEffect = /*#__PURE__*/memo(function (_ref) {
  var sentences = _ref.sentences,
    _ref$as = _ref.as,
    Component = _ref$as === void 0 ? 'div' : _ref$as,
    _ref$typingSpeed = _ref.typingSpeed,
    typingSpeed = _ref$typingSpeed === void 0 ? 100 : _ref$typingSpeed,
    _ref$initialDelay = _ref.initialDelay,
    initialDelay = _ref$initialDelay === void 0 ? 0 : _ref$initialDelay,
    _ref$pauseDuration = _ref.pauseDuration,
    pauseDuration = _ref$pauseDuration === void 0 ? 2000 : _ref$pauseDuration,
    _ref$deletingSpeed = _ref.deletingSpeed,
    deletingSpeed = _ref$deletingSpeed === void 0 ? 50 : _ref$deletingSpeed,
    _ref$deletePauseDurat = _ref.deletePauseDuration,
    deletePauseDuration = _ref$deletePauseDurat === void 0 ? 0 : _ref$deletePauseDurat,
    _ref$loop = _ref.loop,
    loop = _ref$loop === void 0 ? true : _ref$loop,
    _ref$className = _ref.className,
    className = _ref$className === void 0 ? '' : _ref$className,
    color = _ref.color,
    _ref$showCursor = _ref.showCursor,
    showCursor = _ref$showCursor === void 0 ? true : _ref$showCursor,
    _ref$hideCursorWhileT = _ref.hideCursorWhileTyping,
    hideCursorWhileTyping = _ref$hideCursorWhileT === void 0 ? false : _ref$hideCursorWhileT,
    cursorCharacter = _ref.cursorCharacter,
    _ref$cursorClassName = _ref.cursorClassName,
    cursorClassName = _ref$cursorClassName === void 0 ? '' : _ref$cursorClassName,
    cursorColor = _ref.cursorColor,
    _ref$cursorBlinkDurat = _ref.cursorBlinkDuration,
    cursorBlinkDuration = _ref$cursorBlinkDurat === void 0 ? 0.8 : _ref$cursorBlinkDurat,
    _ref$cursorFade = _ref.cursorFade,
    cursorFade = _ref$cursorFade === void 0 ? true : _ref$cursorFade,
    _ref$cursorStyle = _ref.cursorStyle,
    cursorStyle = _ref$cursorStyle === void 0 ? 'pipe' : _ref$cursorStyle,
    _ref$textColors = _ref.textColors,
    textColors = _ref$textColors === void 0 ? [] : _ref$textColors,
    variableSpeed = _ref.variableSpeed,
    onSentenceComplete = _ref.onSentenceComplete,
    _ref$startOnVisible = _ref.startOnVisible,
    startOnVisible = _ref$startOnVisible === void 0 ? false : _ref$startOnVisible,
    _ref$reverseMode = _ref.reverseMode,
    reverseMode = _ref$reverseMode === void 0 ? false : _ref$reverseMode,
    _ref$segmentMode = _ref.segmentMode,
    segmentMode = _ref$segmentMode === void 0 ? 'grapheme' : _ref$segmentMode,
    props = _objectWithoutProperties(_ref, _excluded);
  var _useStyles = useStyles(),
    styles = _useStyles.styles,
    cx = _useStyles.cx;
  var _useState = useState(''),
    _useState2 = _slicedToArray(_useState, 2),
    displayedText = _useState2[0],
    setDisplayedText = _useState2[1];
  var _useState3 = useState(0),
    _useState4 = _slicedToArray(_useState3, 2),
    currentCharIndex = _useState4[0],
    setCurrentCharIndex = _useState4[1];
  var _useState5 = useState(false),
    _useState6 = _slicedToArray(_useState5, 2),
    isDeleting = _useState6[0],
    setIsDeleting = _useState6[1];
  var _useState7 = useState(0),
    _useState8 = _slicedToArray(_useState7, 2),
    currentTextIndex = _useState8[0],
    setCurrentTextIndex = _useState8[1];
  var _useState9 = useState(!startOnVisible),
    _useState10 = _slicedToArray(_useState9, 2),
    isVisible = _useState10[0],
    setIsVisible = _useState10[1];
  var _useState11 = useState(false),
    _useState12 = _slicedToArray(_useState11, 2),
    isDeletePausing = _useState12[0],
    setIsDeletePausing = _useState12[1];
  var containerRef = useRef(null);
  var textArray = useMemo(function () {
    return Array.isArray(sentences) ? sentences : [sentences];
  }, [sentences]);

  // Helper function to split text based on segment mode
  var splitText = useCallback(function (text) {
    // Use Intl.Segmenter if available
    if (typeof Intl !== 'undefined' && 'Segmenter' in Intl) {
      var segmenter = new Intl.Segmenter(undefined, {
        granularity: segmentMode
      });
      return Array.from(segmenter.segment(text), function (segment) {
        return segment.segment;
      });
    }

    // Fallback when Intl.Segmenter is not available
    if (segmentMode === 'word') {
      // Simple word splitting fallback
      return text.split(/(\s+)/).filter(Boolean);
    }

    // Grapheme fallback
    return Array.from(text);
  }, [segmentMode]);
  var getRandomSpeed = useCallback(function () {
    if (!variableSpeed) return typingSpeed;
    var min = variableSpeed.min,
      max = variableSpeed.max;
    return Math.random() * (max - min) + min;
  }, [variableSpeed, typingSpeed]);
  var getCurrentTextColor = function getCurrentTextColor() {
    if (textColors.length > 0) {
      return textColors[currentTextIndex % textColors.length];
    }
    return color;
  };
  var getCurrentCursorColor = function getCurrentCursorColor() {
    return cursorColor || color;
  };
  useEffect(function () {
    if (!startOnVisible || !containerRef.current) return;
    var observer = new IntersectionObserver(function (entries) {
      entries.forEach(function (entry) {
        if (entry.isIntersecting) {
          setIsVisible(true);
        }
      });
    }, {
      threshold: 0.1
    });
    observer.observe(containerRef.current);
    return function () {
      return observer.disconnect();
    };
  }, [startOnVisible]);
  useEffect(function () {
    if (!isVisible) return;
    var timeout;
    var currentText = textArray[currentTextIndex];
    // Split text based on segment mode
    var textSegments = splitText(currentText);
    var processedText = reverseMode ? textSegments.reverse().join('') : currentText;

    // Handle delete pause state
    if (isDeletePausing) {
      timeout = setTimeout(function () {
        setIsDeletePausing(false);
      }, deletePauseDuration);
      return function () {
        return clearTimeout(timeout);
      };
    }
    var executeTypingAnimation = function executeTypingAnimation() {
      if (isDeleting) {
        if (displayedText === '') {
          setIsDeleting(false);
          if (currentTextIndex === textArray.length - 1 && !loop) {
            return;
          }
          if (onSentenceComplete) {
            onSentenceComplete(textArray[currentTextIndex], currentTextIndex);
          }
          setCurrentTextIndex(function (prev) {
            return (prev + 1) % textArray.length;
          });
          setCurrentCharIndex(0);
          if (deletePauseDuration > 0) {
            setIsDeletePausing(true);
            return;
          }
        } else {
          timeout = setTimeout(function () {
            setDisplayedText(function (prev) {
              var segments = splitText(prev);
              return segments.slice(0, -1).join('');
            });
          }, deletingSpeed);
        }
      } else {
        var processedSegments = splitText(processedText);
        if (currentCharIndex < processedSegments.length) {
          timeout = setTimeout(function () {
            setDisplayedText(function (prev) {
              return prev + processedSegments[currentCharIndex];
            });
            setCurrentCharIndex(function (prev) {
              return prev + 1;
            });
          }, variableSpeed ? getRandomSpeed() : typingSpeed);
        } else if (textArray.length >= 1) {
          if (!loop && currentTextIndex === textArray.length - 1) return;
          timeout = setTimeout(function () {
            setIsDeleting(true);
          }, pauseDuration);
        }
      }
    };
    if (currentCharIndex === 0 && !isDeleting && displayedText === '') {
      timeout = setTimeout(executeTypingAnimation, initialDelay);
    } else {
      executeTypingAnimation();
    }
    return function () {
      return clearTimeout(timeout);
    };
  }, [currentCharIndex, displayedText, isDeleting, isDeletePausing, typingSpeed, deletingSpeed, deletePauseDuration, pauseDuration, textArray, currentTextIndex, loop, initialDelay, isVisible, reverseMode, variableSpeed, onSentenceComplete, getRandomSpeed, splitText]);
  var getCursorStyle = function getCursorStyle() {
    if (cursorCharacter) return styles.cursorCustom;
    switch (cursorStyle) {
      case 'block':
        {
          return styles.cursorBlock;
        }
      case 'dot':
        {
          return styles.cursorDot;
        }
      case 'underscore':
        {
          return styles.cursorUnderscore;
        }
      case 'pipe':
        {
          return styles.cursor;
        }
    }
  };
  var currentTextLength = splitText(textArray[currentTextIndex]).length;
  var isTyping = currentCharIndex < currentTextLength && !isDeleting;
  var isAfterTyping = currentCharIndex === currentTextLength && !isDeleting;
  var shouldHideCursor = function () {
    if (hideCursorWhileTyping === true) return true; // 完全隐藏
    if (hideCursorWhileTyping === 'typing') return isTyping || isDeleting; // 打字和删除时隐藏
    if (hideCursorWhileTyping === 'afterTyping') return isAfterTyping; // 打字完成后隐藏
    return false;
  }();
  var textColor = getCurrentTextColor();
  var finalCursorColor = getCurrentCursorColor();

  // Split displayed text for animation
  var characters = splitText(displayedText);
  return /*#__PURE__*/createElement(Component, _objectSpread({
    className: cx(styles.container, className),
    ref: containerRef
  }, props), /*#__PURE__*/_jsxs(_Fragment, {
    children: [/*#__PURE__*/_jsx("span", {
      className: styles.text,
      style: textColor ? {
        color: textColor
      } : undefined,
      children: characters.map(function (char, index) {
        return /*#__PURE__*/_jsx(motion.span, {
          animate: {
            opacity: 1
          },
          initial: {
            opacity: 0
          },
          style: {
            display: 'inline-block'
          },
          transition: {
            duration: typingSpeed / 500,
            ease: 'easeInOut'
          },
          children: char === ' ' ? "\xA0" : char
        }, "".concat(currentTextIndex, "-").concat(index));
      })
    }), showCursor && (cursorFade ? /*#__PURE__*/_jsx(motion.span, {
      animate: {
        opacity: shouldHideCursor ? 0 : 1
      },
      className: cx(getCursorStyle(), cursorClassName),
      initial: {
        opacity: 0
      },
      style: finalCursorColor ? {
        backgroundColor: finalCursorColor
      } : undefined,
      transition: {
        duration: shouldHideCursor ? 0.2 : cursorBlinkDuration,
        ease: 'easeInOut',
        repeat: shouldHideCursor ? 0 : Number.POSITIVE_INFINITY,
        repeatType: 'reverse'
      },
      children: cursorCharacter
    }) : /*#__PURE__*/_jsx("span", {
      className: cx(getCursorStyle(), cursorClassName),
      style: {
        backgroundColor: finalCursorColor,
        opacity: shouldHideCursor ? 0 : 1
      },
      children: cursorCharacter
    }))]
  }));
});
TypewriterEffect.displayName = 'TypewriterEffect';
export default TypewriterEffect;